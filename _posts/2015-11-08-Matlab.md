---
layout: post
title: Matlab 中容易忽视的
categories: [blog ]
tags: [Matlab, 工具]
description: Matlab中容易忽视的地方
---

假设我们有一个2*3的矩阵A, 有一个向量V；

## Matlab Tips

* %不再是取模了，而表示是注释
* ' 矩阵转置
* lookfor与help命令
help精确查找，lookfor是内容查找，比help慢很多
* ;
没有分号，显示之
* disp 显示提示信息
* fprintf(format,data) , e.g. `fprint('The value of pi is %6.2f\n',pi)`
* ~= 不等于

##逻辑数组的应用
mask可以从一个数组中选择需要的元素参与运算，指定运算只在选择元素上执行

```matlab
	maxcount = 1; One repetition  
	tic; Start timer   
	for jj = 1:maxcount   
		a = 1:10000; 		%Declare array a    
		for ii = 1:10000   
		    if a(ii) > 5000   
			a(ii) = sqrt(a(ii));   
		    end        
		end   
	end    
	average1 = (toc)/maxcount; %Calculate average time  
	Perform calculation using logical arrays.  
	maxcount = 10; %One repetition   
	tic; %Start timer  
	for jj = 1:maxcount   
	 	a = 1:10000; 		%Declare array a   
	 	b = a > 5000; 		%Create mask   
	 	a(b) = sqrt(a(b)); 	%Take square root  
	end   
	average2 = (toc)/maxcount; %Calculate average time  
```


##数组

* size
`size(V)`不是一个数字,而是一个1*2的向量，这一个千万要注意。

* diag的应用
假设矩阵C表示n个点的坐标，$C_i$表示第i个点，那么所有点到原点的坐标计算：
	`D = diag(A*A')` 其中D为n维列向量

* end函数
返回*所要*数组下标的最大值

## 矩阵运算
* 矩阵右除法 `A/B` 矩阵除法,等价于 `A*inv(B)`, `inv(B)`是 `B` 的逆阵
* 矩阵左除法 `A\B` 矩阵除法,等价于 `inv(A)*B`, `inv(A)`是 `A `的逆阵
* 数组加法 `A+B`数组加法和矩阵加法相同
* 数组减法 `AB` 数组减法和矩阵减法相同
* 数组乘法 A.*B A 和 B 的元素逐个对应相乘.两数组之间必须有相同的形,或其中一个是标量.
* 矩阵乘法 A*B A 和 B 的矩阵乘法.A 的列数必须和 B 的行数相同.
* 数组右除法 A./B A 和 B 的元素逐个对应相除:A(i,j)/B(i,j)两数组之间必须有相同的形,或其中一个是标量.
* 数组左除法 A.\B A 和 B 的元素逐个对应相除:B(i,j)/A(i,j)两数组之间必须有相同的形,或其中一个是标量.
* 数组指数运算 A.^B AB 中的元素逐个进行如下运算 A(i,j)^B(i,j),A(i,j)/B(i,j)两数组之间必须有相同的形,或其中一个是标量. 

##常用函数
* zeros
* ones
* diag 
* inv 求矩阵的逆矩阵
* pinv 表示伪逆矩阵
* rank(A) 求矩阵A的
* [V D] = eig(A)


## 常用函数如下：函数命令 说明 

### 变量声明
由m行n列构成的数组称为(m×n)阶矩阵。 
用"[]"方括号定义矩阵；其中方括号内","逗号或" "空格号分隔矩阵列数值；";"分号或"Enter"回车键分隔矩阵行数值。 
例：`a=[a11 a12 a13;a21 a22 a23]`或`a=[a11,a12,a13;a21,a22,a23]`定义了一个2*3 阶矩阵a。 
`aij`可以为数值、变量、表达式或字符串，如为数值与变量得先赋值，表达式和变量可以以任何组合形式出现，字符串须每一行中的字母个数相等 ，调用时缺省状态按行顺序取字母,如a(1)为第一行第一个字母。 

1. `-size(a)` 
`[d1,d2,d3,..] = size(a)`  
求矩阵的大小，对m*n二维矩阵，第一个为行数m,第二个为列数n;对多维矩阵，第N个为矩阵第N维的长度。

2. `-cat(k,a,b)`  矩阵合并,运行`a = magic(3) `
`b = pascal(3)` 
`c = cat(4,a,b)` 
改4为3或2或1，自己体会合并后的效果。 
k=1,合并后形如 [a;b],行添加矩阵(要求a,b的列数相等才能合并）； 
k=2,合并后形如[a,b],列添加矩阵(要求a,b的行数相等才能合并）,以此类推,n维的矩阵合并，要求n-1维维数相等才可以）。 

3. 
`-fliplr(a)` 矩阵左右翻转 
`-flipud(a)` 矩阵上下翻转 

`-rot90(a)` 
`rot90(a,k)` 矩阵逆时针旋转90度(把你的头顺时针旋转90看原数就可以知道结果了）k参数定义为逆时针旋转90*k度。 

`-flipdim(a,k)` 矩阵对应维数数值翻转,如k=1时，行(上下)翻转，k=2时，列(左右)翻转。 

4. `-tril(a)` 
`tril(a,k)` 矩阵的下三角部分(包括对角线元素），对应k=0时的取值数.k参数设置为正负数值对应对角线向上或向下移动k行划分下三角元素。

`-triu(a)` 
tril(a,k) 矩阵的上三角部分(包括对角线元素），对应k=0时的取值数。 
k参数设置为正负数值对应对角线向上或向下移动k行划分上三角元素。 

4.` -diag(a) `
diag(a,k) 生成对角矩阵或取出对角元素，对应k=0时的取值数。 
k参数设置为正负数值对应对角线向上或向下移动k行取对角元素或生成对角矩阵。

5. `-repmat(a,m,n)` 矩阵复制,把矩阵a作为一个单位计算，复制成m*n的矩阵，其每 
一元素都含一个矩阵a,实际结果为一个`size(a,1)*m`行，`size(a,2)*n`列的矩阵。 

6.`-w=meshgrid(s,t)` 
[u,v]=meshgrid(s,t) 生成行m＝size(t,1)*size(t,2),列n＝size(s,1)*size(s,2)) 
阶的两个矩阵。其中u为按行顺序取s的n个矩阵元数,按列排列重复m行,v为按列顺序取t的 
m个矩阵元数 ，按行排列重复n列。只生成一个矩阵时，w=u。 

7. `-eye(a)` 
`eye(a,k)` 生成a阶单位方阵 
k参数设置为生成a×k阶单位矩阵,即生成a阶单位方阵后，取前k列,不足补0。 

`-ones(a)` 
ones(a,k) 生成a阶全1方阵 
k参数设置生成a×k阶全1矩阵。 

`-zeros(a)` 
`zeros(a,k)` 生成a阶全0方阵 
k参数设置生成a×k阶全0矩阵。 

8. `-inv(a)` 生成a的逆矩阵 

`-length(a)` 求矩阵的长度的函数 

## Matlab example

1. 通过在矩阵变量后加’的方法来表示转置运算 

```matlab
a=[10,2,12;34,2,4;98,34,6]; 

a' 
```

	ans = 
	10 34 98 
	2 2 34 
	12 4 6 

2. 矩阵求逆 

`inv(a) `

	ans = 
	-0.0116 0.0372 -0.0015 
	0.0176 -0.1047 0.0345 
	0.0901 -0.0135 -0.0045 

3. 矩阵求伪逆 

`pinv(a) `

	ans = 
	-0.0116 0.0372 -0.0015 
	0.0176 -0.1047 0.0345 
	0.0901 -0.0135 -0.0045 

4. 左右反转 

`fliplr(a) `

	ans = 
	12 2 10 
	4 2 34 
	6 34 98 

5. 矩阵的特征值 

`[u,v]=eig(a)` 

	u = 
	-0.2960 0.3635 -0.3600 
	-0.2925 -0.4128 0.7886 
	-0.9093 -0.8352 0.4985 

	v = 
	48.8395 0 0 
	0 -19.8451 0 
	0 0 -10.9943 

6. 上下反转 

`flipud(a)`

	ans = 
	98 34 6 
	34 2 4 
	10 2 12 

7. 旋转90度 

`rot90(a) ` 

	ans = 
	12 4 6 
	2 2 34 
	10 34 98 

8. 取出上三角和下三角 

`triu(a)` 

	ans = 
	10 2 12 
	0 2 4 
	0 0 6 

`tril(a)`  

	ans = 
	10 0 0 
	34 2 0 
	98 34 6 

`[l,u]=lu(a) ` 

	l = 
	0.1020 0.1500 1.0000 
	0.3469 1.0000 0 
	1.0000 0 0 

	u = 
	98.0000 34.0000 6.0000  
	0 -9.7959 1.9184 
	0 0 11.1000 

9. 正交分解 

`[q,r]=qr(a)` 
 
	q = 
	-0.0960 -0.1232 -0.9877 
	-0.3263 -0.9336 0.1482 
	-0.9404 0.3365 0.0494 

	r = 
	-104.2113 -32.8179 -8.0989 
	0 9.3265 -3.1941  
	0 0 -10.9638 
 
10．奇异值分解 

`[u,s,v]=svd(a) `
 
	u = 
	0.1003 -0.8857 0.4532 
	0.3031 -0.4066 -0.8618 
	0.9477 0.2239 0.2277 

	s = 
	109.5895 0 0 
	0 12.0373 0 
	0 0 8.0778 

	v = 
	0.9506 -0.0619 -0.3041 
	0.3014 0.4176 0.8572 
	0.0739 -0.9065 0.4156 

11. 求矩阵的范数 

`norm(a)` 
	
	ans = 109.5895 

`norm(a,1)` 

	ans = 142 

`norm(a,inf)` 
	
	ans = 138

##数据文件
`save filename var1 var 2`      
`load('filename.mat')`

## 编程规范
* **Matlab以列为主导顺序分配内存**
* 确保变量名前三十一个字符时独一无二的，否则Matlab将辨认不出两个变量的不同
	定义变量min
	script中调用内置函数min
	则将min和变量min不能够识别
* 如果变量名和Matlab函数名或者命令重名，那么这个函数或者命令将不能被访问
* 不要创建和matlab内建函数或者命令重名的M文件
		which filename查看要加载的文件路径
* 在你所写的程序的开头列出一数据字典(data dictionary)十分的重要.数据字典列举了你在本程序中用到的所有变量的定义。它的定义应包括本条目的所要描述的内容和它在执行时所在的单元。当编写程序时，编定数据字典看似没有必要。但是设想一下，在过了一段时间后，你或其他人要对此程序修改，这时数据字典就显得十分的有用。
* 变量名用小写
* 不要重定义有意义的预定义变量。否则将后患无穷，制造成出小而难以发现的错误。
	pi    圆周率  
	i,j   虚数单位  
	Inf   无穷大  
	NaN    
	clock  
	date  
	eps  
	ans  
* 那种既可以用向量可以解决的问题，也可以用循环解决的问题，最好用向量解决，这是因为向量执行的速度快。

循环法

	for ii = 1:100  
		square(ii) = ii ^2;  
		square_root(ii) = ii ^ (1/2);   
		cube_root(ii) = ii ^ (1/3);   
	end 


改进后 

	ii = 1:100;  
	square = ii .^2; 
	square_root = ii .^ (1/2);  
	cube_root(ii) = ii .^ (1/3);   

更多信息，可以参看[matlab](http://www.yiibai.com/matlab/matlab_algebra.html)

# MATLAB 高级教程--常用函数

### 函数bsxfun
【功能描述】两个数组间元素逐个计算.
【应用场合】当我们想对一个矩阵A的每一列或者每一行与同一个长度相等的向量a进行某些操作(比较大小，乘除等）时，我们只能用循环方法或者利用repmat函数将要操作的向量a复制成和A一样尺寸的矩阵，进而进行操作。从MATLAB R2007a开始，再遇到类似的问题时，我们有了简洁高效的方法，即利用bsxfun函数。
【函数描述】C=bsxfun(fun,A,B)：两个数组间元素逐个计算，fun是函数句柄或者m文件，也可以为如下内置函数 
         @plus 加 
         @minus 减 
         @times 数组乘 
         @rdivide 左除 
         @ldivide 右除 
For example： 如何将一个矩阵的每行或每列元素分别扩大不同的倍数？如[1 2 3;4 5 6 ;7 8 9],第一列元素乘以1，第二列元素以2，第三列元素乘以4。
利用bsxfun函数，可以给出下列代码：

	a = [1,2,3;4,5,6;7,8,9];
	acol = bsxfun(@times,a,[1 2 4])

### repmat函数用法
复制和平铺矩阵

	B = repmat(A,m,n)       %将矩阵A复制m×n块，即B由m×n块A平铺而成。
	B = repmat(A,[m n])      %与上面一致
	B = repmat(A,[m n p…])   %B由m×n×p×…个A块平铺而成
	repmat(A,m,n)           %当A是一个数a时，该命令产生一个全由a组成的m×n矩阵。
	B=repmat(A,m,n)： 把矩阵A复制n*m份，并堆叠构成矩阵B，矩阵B的大小为[size(A,1)*m, size(A,2)*n]

### spdiags函数
用法：是提取和创建稀疏带和对角矩阵的函数。

	*[B,D] = spdiags(A)，从矩阵A中取出所有非零对角元素，并保存在矩阵B中,向量D表示非零元素的对角线位置.
	例如1：
	A = [11 0 13 0
	0 22 0 24
	0 0 33 0
	41 0 0 44
	0 52 0 0
	0 0 63 0
	0 0 0 74]
	这里 m = 7, n = 4, p = 3.
	[B,d] = spdiags(A)
	B =
	41 11 0
	52 22 0
	63 33 13
	74 44 24
	d =
	-3
	0
	2

	* B = spdiags(A，D)
	从矩阵A中取出由D指定的对角线元素，并保存在矩阵B中。
	* A = spdiags(B，D ,m, n)		
	产生一个m×n稀疏矩阵A，其元素是B中的列元素放在由D指定的对角线位置上。


	例如2：
	n=3; e = ones(n,1);A = spdiags([e -2*e e], -1:1, n, n)
	A =
	(1,1) -2
	(2,1) 1
	(1,2) 1
	(2,2) -2
	(3,2) 1
	(2,3) 1
	(3,3) -2

	例如3： spdiags(B,d,7,4)
	ans =
	(1,1) 11
	(4,1) 41
	(2,2) 22
	(5,2) 52
	(1,3) 13
	(3,3) 33
	(6,3) 63
	(2,4) 24
	(4,4) 44
	(7,4) 74