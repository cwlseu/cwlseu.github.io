


## Google Protocol Buffer
序列化协议。

|:-----:   |:----:   |:-----:  |:-------:|:-----:        |:-----:   |:-------:     |:-----:    |
|          |protobuf | jackson | xstream | serialization | hessian2 | hessian2压缩 | hessian 1 |
| 序列化 ns| 1154    | 5421    | 92406   |  10189        | 26794    | 100766       | 29027     |
|反序列化ns| 1334    | 8743    | 117329  |         64027 | 37871    | 188432       | 37596     |
| bytes    | 97      | 311     | 664     | 824           | 374      | 283          | 495       |

- protobuf 不管是处理时间上，还是空间占用上都优于现有的其他序列化方式。内存暂用是java序列化的1/9，
时间也是差了一个数量级，一次操作在1us左右。缺点：就是对象结构体有限制，只适合于内部系统使用。

- json格式在空间占用还是有一些优势，是java序列化的1/2.6。序列化和反序列化处理时间上差不多，也就在5us。当然这次使用的jackson，如果使用普通的jsonlib可能没有这样好的性能，jsonlib估计跟java序列化差不多。

- xml相比于java序列化来说，空间占用上有点优势，但不明显。处理时间上比java序列化多了一个数量级，在100us左右。

- 以前一种的java序列化，表现得有些失望

- hessian测试有点意外，具体序列化数据上还步入json。性能上也不如jackjson，输得比较彻底。
- hessian使用压缩，虽然在字节上有20%以上的空间提升，但性能上差了4,5倍，典型的以时间换空间。总的来说还是google protobuf比较给力
以后在内部系统，数据cache存储上可以考虑使用protobuf。跟外部系统交互上可以考虑使用json。

## 参考文献

[1]. http://agapple.iteye.com/blog/859052