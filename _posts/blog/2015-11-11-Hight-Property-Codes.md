---
layout: post
title: 开发：高质量的C++代码笔记
categories: [blog ]
tags: [C++, 代码质量]
description: 软件质量是被大多数程序员挂在嘴上而不是放在心上的东西！除了完全外行和真正的编程高手外，初读本书，你最先的感受将是惊慌：“哇！我以前捏造的 C++/C 程序怎么会有那么多的毛病？”有多少软件开发人员对正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等质量属性了如指掌？并且能在实践中运用自如？。
--- 

- 声明：本博客欢迎转发，但请保留原作者信息!
- 作者: [曹文龙]
- 博客： <https://cwlseu.github.io/>

软件质量是被大多数程序员挂在嘴上而不是放在心上的东西！
除了完全外行和真正的编程高手外，初读本书，你最先的感受将是惊慌：“哇！我
以前捏造的 C++/C 程序怎么会有那么多的毛病？”有多少软件开发人员对正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等质量属性了如指掌？并且能在实践中运用自如？。

## 从小程序看问题

`strcpy`的实现可以看出一个人的
* 编程风格
* 出错处理
* 算法复杂度分析

```cpp
char* strcpy(char* dest, const char* source)
{
    char * destcopy = dest;
    if((dest == NULL) || (source == NULL))
        throw "Invalid Arguments";
    while((*dest++=*source++)!= '\0');
    return destcopy;
}
```

## 文件结构
1. 声明在头文件.h，定义在源代码文件.cpp或者.c .cc
2. 为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预
处理块。
3. 用 #include <filename.h> 格式来引用标准库的头文件（编译器将
从标准库目录开始搜索）。用 #include “filename.h” 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。
4. 头文件中只存放“声明”而不存放“定义”
5. 不提倡使用全局变量， 尽量不要在头文件中出现象 extern int value 这
类声明。

```cpp
    /*
    * Copyright (c) 2001,上海贝尔有限公司网络应用事业部
    * All rights reserved.
    *
    * 文件名称： filename.h
    
    * 文件标识： 见配置管理计划书
    * 摘 要： 简要描述本文件的内容
    *
    * 当前版本： 1.1
    * 作 者： 输入作者（或修改者）名字
    * 完成日期： 2001年7月20日
    *
    * 取代版本： 1.0
    * 原作者 ： 输入原作者（或修改者）名字
    * 完成日期： 2001年5月10日
    */
```

### 为什么要声明和定义分离：

1. 通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只
要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库
功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。
2. 头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件
中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错
的负担。
3. 便于管理。如果代码文件比较多，可以将头文件放到include目录下，源文件放到source目录下，方便分别管理

## 程序

1. 在每个类声明之后、每个函数定义结束之后都要加空行
2. 在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应
加空行分隔。
3. 一行代码只做一件事情，如只定义一个变量，或只写一条语句。
4. if、 for、 while、 do 等语句自占一行，执行语句不得紧跟其后。不论
执行语句有多少都要加{}。这样可以防止书写失误。
5. 尽可能在定义变量的同时初始化该变量。如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用了未被初始化的变量，可能会导致程序错误。本建议可以减少隐患。

### 指针声明

修饰符 * 和 ＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。
若将修饰符 * 靠近数据类型，例如： int* x; 从语义上讲此写法比较直观，即 x
是 int 类型的指针。
上述写法的弊端是容易引起误解，例如： int* x, y; 此处 y 容易被误解为指针变
量。虽然将 x 和 y 分行定义可以避免误解，但并不是人人都愿意这样做。

## 命名规则

unix系统中常常采用小写字母+_ 的方式
g_:全局变量
k_:static 变量
m_：class成员变量


## 类的构造函数、析构函数和赋值函数

每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝
构造函数，其它的称为普通构造函数）。对于任意一个类 A，如果不想编写上述函数，
C++编译器将自动为 A 产生四个缺省的函数，如
`A(void);`              // 缺省的无参数构造函数
`A(const A &a); `       // 缺省的拷贝构造函数
`~A(void);`             // 缺省的析构函数
`A & operate =(const A &a); `   // 缺省的赋值函数


## 经验

不少难以察觉的程序错误是由于变量没有被正确初始化或清除造成的，而初始化和清除工作很容易被人遗忘。