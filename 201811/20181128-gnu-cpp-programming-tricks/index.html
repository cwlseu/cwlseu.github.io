<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CTimes+New+Roman:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.deepindeed.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":28},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="如果不是使用C++开发过大型系统项目，可能一些编程语言的feature将继续雪藏，让我们一起来挖掘这些秘密吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Programming Tricks">
<meta property="og:url" content="http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/index.html">
<meta property="og:site_name" content="Deepindeed">
<meta property="og:description" content="如果不是使用C++开发过大型系统项目，可能一些编程语言的feature将继续雪藏，让我们一起来挖掘这些秘密吧。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-11-28T15:22:12.000Z">
<meta property="article:modified_time" content="2022-08-29T15:04:26.122Z">
<meta property="article:author" content="CharlesCao">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="开发">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/","path":"201811/20181128-gnu-cpp-programming-tricks/","title":"C++ Programming Tricks"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Programming Tricks | Deepindeed</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-86501439-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-86501439-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




<link rel="dns-prefetch" href="https://waline.vercel.app"><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Deepindeed</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">心有猛虎，细嗅蔷薇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tools"><a href="/tools/" rel="section"><i class="fa fa-globe fa-fw"></i>tools</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#pragma-warning"><span class="nav-number">1.</span> <span class="nav-text">pragma warning</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8E%BB%E8%AD%A6%E5%91%8A"><span class="nav-number">1.0.1.</span> <span class="nav-text">常用去警告：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95"><span class="nav-number">1.0.2.</span> <span class="nav-text">常用用法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-%E6%94%AF%E6%8C%81"><span class="nav-number">1.0.3.</span> <span class="nav-text">#pragma 支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Epragma-warning"><span class="nav-number">1.1.</span> <span class="nav-text">关于#pragma warning</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cc-%E5%AE%8F%E5%AE%9A%E4%B9%89define%E4%B8%AD-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">C++&#x2F;C 宏定义（define）中# ##
的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gnu-c%E4%B8%AD%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E7%89%B9%E8%89%B2__attribute__%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">GNU
C中不为人知的特色：__attribute__机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7variable-attribute"><span class="nav-number">4.</span> <span class="nav-text">变量属性(Variable Attribute)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aligned-alignment"><span class="nav-number">4.1.</span> <span class="nav-text">aligned (alignment)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7type-attribute"><span class="nav-number">5.</span> <span class="nav-text">类型属性（Type Attribute）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aligned-alignment-1"><span class="nav-number">5.1.</span> <span class="nav-text">aligned (alignment)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E4%B8%BE%E4%BE%8B"><span class="nav-number">6.</span> <span class="nav-text">变量属性与类型属性举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#declspec"><span class="nav-number">7.</span> <span class="nav-text">__declspec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcc-__attribute__%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BE%E4%BE%8B%E4%B9%8Bvisibility"><span class="nav-number">8.</span> <span class="nav-text">gcc
__attribute__关键字举例之visibility</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84-gcc-%E7%89%B9%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">Linux 内核中的 GCC 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E6%89%A9%E5%B1%95"><span class="nav-number">1.</span> <span class="nav-text">功能性扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%91%E7%8E%B0"><span class="nav-number">1.1.</span> <span class="nav-text">类型发现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%89%A9%E5%B1%95"><span class="nav-number">1.2.</span> <span class="nav-text">范围扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">零长度的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%B0%83%E7%94%A8%E5%9C%B0%E5%9D%80"><span class="nav-number">1.4.</span> <span class="nav-text">判断调用地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%A3%80%E6%B5%8B"><span class="nav-number">1.5.</span> <span class="nav-text">常量检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">函数属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%89%A9%E5%B1%95"><span class="nav-number">2.</span> <span class="nav-text">优化扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E6%8F%90%E7%A4%BA"><span class="nav-number">2.1.</span> <span class="nav-text">分支预测提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%8A%93%E5%8F%96"><span class="nav-number">2.2.</span> <span class="nav-text">预抓取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">变量属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CharlesCao"
      src="/images/bird.png">
  <p class="site-author-name" itemprop="name">CharlesCao</p>
  <div class="site-description" itemprop="description">In me the tiger sniffs the rose.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:caowenlong92@gmail.com" title="E-Mail → mailto:caowenlong92@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/5221628" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;5221628" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/cwlseu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cwlseu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://pytorch.org/" title="https:&#x2F;&#x2F;pytorch.org" rel="noopener" target="_blank">Pytorch</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cplusplus.com/reference" title="https:&#x2F;&#x2F;cplusplus.com&#x2F;reference" rel="noopener" target="_blank">CppReference</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://docs.nvidia.com/cuda/index.html" title="https:&#x2F;&#x2F;docs.nvidia.com&#x2F;cuda&#x2F;index.html" rel="noopener" target="_blank">NVIDIA CUDA</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/cwlseu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bird.png">
      <meta itemprop="name" content="CharlesCao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deepindeed">
      <meta itemprop="description" content="In me the tiger sniffs the rose.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Programming Tricks | Deepindeed">
      <meta itemprop="description" content="如果不是使用C++开发过大型系统项目，可能一些编程语言的feature将继续雪藏，让我们一起来挖掘这些秘密吧。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Programming Tricks
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-28 23:22:12" itemprop="dateCreated datePublished" datetime="2018-11-28T23:22:12+08:00">2018-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-29 23:04:26" itemprop="dateModified" datetime="2022-08-29T23:04:26+08:00">2022-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论数：</span>
  
    <a title="waline" href="/201811/20181128-gnu-cpp-programming-tricks/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/201811/20181128-gnu-cpp-programming-tricks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

            <div class="post-description">如果不是使用C++开发过大型系统项目，可能一些编程语言的feature将继续雪藏，让我们一起来挖掘这些秘密吧。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="pragma-warning"><code>pragma warning</code></h2>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3350852/how-to-correctly-fix-zero-sized-array-in-struct-union-warning-c4200-without">关于warning的一个问题：
warning C4200: nonstandard extension used : zero-sized array in
struct/union Cannot generate copy-ctor or copy-assignment operator when
UDT contains a zero-sized array</a></p>
<h4 id="常用去警告">常用去警告：</h4>
<ul>
<li><code>#pragma warning(disable:4035)</code> //no return value</li>
<li><code>#pragma warning(disable:4068)</code> //unknown pragma</li>
<li><code>#pragma warning(disable:4201)</code> //nonstandard extension
used : nameless struct/union</li>
<li><code>#pragma warning(disable:4267)</code></li>
<li><code>#pragma warning(disable:4018)</code> //signed/unsigned
mismatch</li>
<li><code>#pragma warning(disable:4127)</code> //conditional expression
is constant</li>
<li><code>#pragma warning(disable:4146)</code></li>
<li><code>#pragma warning(disable:4244)</code> //conversion from
'LONG_PTR' to 'LONG', possible loss of data</li>
<li><code>#pragma warning(disable:4311)</code> //'type cast' : pointer
truncation from 'BYTE *' to 'ULONG'</li>
<li><code>#pragma warning(disable:4312)</code> //'type cast' :
conversion from 'LONG' to 'WNDPROC' of greater size</li>
<li><code>#pragma warning(disable:4346)</code> //_It::iterator_category'
: dependent name is not a type</li>
<li><code>#pragma warning(disable:4786)</code></li>
<li><code>#pragma warning(disable:4541)</code> //'dynamic_cast' used on
polymorphic type</li>
<li><code>#pragma warning(disable:4996)</code> //declared deprecated
?</li>
<li><code>#pragma warning(disable:4200)</code> //zero-sized array in
struct/union</li>
<li><code>#pragma warning(disable:4800)</code> //forcing value to bool
'true' or 'false' (performance warning)</li>
</ul>
<h4 id="常用用法">常用用法:</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span>   <span class="keyword">warning</span>(push) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>   <span class="keyword">warning</span>(disable:XXXX)    <span class="comment">// 需要消除警告的代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>   <span class="keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>
<p>or: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span>   <span class="keyword">warning</span>(disable:XXXX) <span class="comment">// 需要消除警告的代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>   <span class="keyword">warning</span>(enable:XXXX)  <span class="comment">// 如果出现：&#x27;enable&#x27;not valid specifier 用 </span></span></span><br><span class="line">                                <span class="comment">// #pragma   warning(default:XXXX)  代替试试</span></span><br></pre></td></tr></table></figure></p>
<h4 id="pragma-支持"><code>#pragma</code> 支持</h4>
<p>开发人员可以使用 <code>#pragma</code>
指令将警告作为错误处理；还可以启用或禁用警告，如下面的示例所示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (<span class="keyword">error</span>: 6260) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6011) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (enable: 6056)</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Q: #pragma warning (disable : 4996)和#pragma warning (default : 4996) 是干啥用的呢？</code></p>
</blockquote>
<ol type="1">
<li><code>#pragma warning(disable: n)</code> 将某个警报置为失效</li>
<li><code>#pragma warning(default: n)</code> 将报警置为默认
使用VS2005,编译提示"xxxxxx被声明为否决的
这是MS新的C库提供的带有检查的函数,有内存溢出检测。可以防止一部分程序bug,
抵制缓冲区溢出攻击(buffer overflow attack). 但是应该速度上有牺牲。</li>
</ol>
<blockquote>
<p>解决办法 - 所以在你确信安全的情况下,可以用#pragma warning(disable:
4996)消除这个警告 -
建议使用_s的缓冲区安全的版本，而不是简单的屏蔽警告。</p>
</blockquote>
<h3 id="关于pragma-warning">关于#pragma warning</h3>
<ol type="1">
<li><p><code>#pragma warning</code>只对当前文件有效（对于.h，对包含它的cpp也是有效的），
而不是是对整个工程的所有文件有效。当该文件编译结束，设置也就失去作用。</p></li>
<li><p><code>#pragma warning(push)</code> 存储当前报警设置。
<code>#pragma warning(push, n)</code>
存储当前报警设置，并设置报警级别为n。n为从1到4的自然数。</p></li>
<li><p><code>#pragma warning(pop)</code>
恢复之前压入堆栈的报警设置。在一对push和pop之间作的任何报警相关设置都将失效。</p></li>
<li><p><code>#pragma warning(disable: n)</code>
将某个警报置为失效</p></li>
<li><p><code>#pragma warning(default: n)</code> 将报警置为默认</p></li>
<li><p>某些警告如C4309是从上到下生效的。即文件内<code>#pragma warning</code>从上到下遍历，依次生效。</p>
<p>例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4189)</span></span><br><span class="line">      <span class="type">char</span> s;</span><br><span class="line">      s = <span class="number">128</span>;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(default: 4189)</span></span><br><span class="line">      <span class="type">char</span> c;</span><br><span class="line">      c = <span class="number">128</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 则s =
128不会产生C4309报警，而C4309会产生报警。</p></li>
<li><p>某些警告例如C4189是以函数中最后出现的#pragma
warning设置为准的，其余针对该报警的设置都是无效的。 例如：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4189)</span></span><br><span class="line">      <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(default: 4189)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
则C4189仍然会出现，因为default指令是函数的最后一条。在该文件内的其他函数中，如果没有重新设置，C4189也是以<code>#pragma warning(default: 4189)</code>为准。如果重新设置，同样是按照其函数中的最后一个<code>#pragma warning</code>为准。</p></li>
<li><p>某些警告（MSDN认为是大于等于C4700的警告）是在函数结束后才能生效。
例如：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4700)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      <span class="type">int</span> y = x;</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(default:4700)</span></span><br><span class="line">      <span class="type">int</span> z= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则y = x和z =
x都不会产生C4700报警。只有在函数结束后的后的另外一个函数中，<code>#pragma warning(default:4700)</code>才能生效。</p></li>
</ol>
<h2 id="cc-宏定义define中-的含义">C++/C 宏定义（define）中# ##
的含义</h2>
<p>define 中的# ##
一般是用来拼接字符串的，但是实际使用过程中，有哪些细微的差别呢，我们通过几个例子来看看。</p>
<p>#是字符串化的意思，出现在宏定义中的#是把跟在后面的参数转成一个字符串；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple registry for caffe commands.</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*BrewFunction)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;caffe::string, BrewFunction&gt; BrewMap;</span><br><span class="line">BrewMap g_brew_map;</span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">define</span> RegisterBrewFunction(func) \</span></span><br><span class="line"><span class="meta">namespace &#123; \</span></span><br><span class="line"><span class="meta">class __Registerer_##func &#123; \</span></span><br><span class="line"><span class="meta"> public: <span class="comment">/* NOLINT */</span> \</span></span><br><span class="line"><span class="meta">  __Registerer_##func() &#123; \</span></span><br><span class="line"><span class="meta">  g_brew_map[#func] = &amp;func; \</span></span><br><span class="line"><span class="meta">  &#125; \</span></span><br><span class="line"><span class="meta">&#125;; \</span></span><br><span class="line"><span class="meta">__Registerer_##func g_registerer_##func; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> BrewFunction <span class="title">GetBrewFunction</span><span class="params">(<span class="type">const</span> caffe::string&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g_brew_map.<span class="built_in">count</span>(name)) &#123;</span><br><span class="line">  <span class="keyword">return</span> g_brew_map[name];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Available caffe actions:&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (BrewMap::iterator it = g_brew_map.<span class="built_in">begin</span>();</span><br><span class="line">  it != g_brew_map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it-&gt;first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Unknown action: &quot;</span> &lt;&lt; name;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// not reachable, just to suppress old compiler warnings.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是Caffe源码tools/caffe.cpp中的一段程序，主要完成了caffe不同工作阶段的注册工作。如caffe可以在
<code>train, test</code>
等不同环境下工作。每个环境对应着响应的处理函数。这些函数是如何通过main函数统一管理的。就是通过这个<code>GetBrewFunction</code>函数统一调用的。那么这个函数如何获取具体的调用函数，就得知道函数指针和宏替换的相关知识了。具体参考<a
target="_blank" rel="noopener" href="https://github.com/BVLC/caffe/blob/master/tools/caffe.cpp">caffe.cpp</a></p>
<h2 id="gnu-c中不为人知的特色__attribute__机制">GNU
C中不为人知的特色：<code>__attribute__</code>机制</h2>
<p>偶然碰到了<code>__attribute__</code>，虽然之前在看Linux内核代码时见过很多次，但还是对它熟视无睹，罪过啊，下面的文章是从源码网上转载的，原文在这里:http://www.yuanma.org/data/2006/0625/article_948.htm，此处只是做简单阐述，共同进步。</p>
<ol type="1">
<li><p>GNU
C的一大特色（却不被初学者所知）就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置函数属性（Function
Attribute）、变量属性（Variable Attribute）和类型属性（Type
Attribute）。它的书写特征是：<code>__attribute__</code>前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的<code>__attribute__</code>参数，语法格式如下：
<code>__attribute__ ((attribute-list))</code></p></li>
<li><p>另外，它必须放于声明的尾部“；”之前。</p></li>
</ol>
<p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<code>__attribute__</code>机制也很容易同非GNU应用程序做到兼容之功效。</p>
<p><strong>GNU CC需要使用
–Wall编译器来击活该功能</strong>，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。</p>
<p><code>__attribute__ format</code>。该<code>__attribute__</code>属性可以给被声明的函数加上类似<code>printf</code>或者<code>scanf</code>的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。<code>format</code>的语法格式为：</p>
<p><code>format (archetype, string-index, first-to-check)</code></p>
<p>format属性告诉编译器，按照printf, scanf,
strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。</p>
<ol start="3" type="1">
<li>具体使用格式如下： <code>__attribute__((format(printf,m,n)))</code>
<code>__attribute__((format(scanf,m,n)))</code></li>
</ol>
<p>其中参数m与n的含义为： * m：第几个参数为格式化字符串（format
string）； *
n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到；</p>
<p>在使用上，<code>__attribute__((format(printf,m,n)))</code>是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//m=1；n=2</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format,...)</span> __<span class="title">attribute__</span><span class="params">((format(printf,<span class="number">1</span>,<span class="number">2</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//m=2；n=3</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> l，<span class="type">const</span> <span class="type">char</span> *format,...)</span> __<span class="title">attribute__</span><span class="params">((format(printf,<span class="number">2</span>,<span class="number">3</span>)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//m=3；n=4</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> l，<span class="type">const</span> <span class="type">char</span> *format,...)</span> __<span class="title">attribute__</span><span class="params">((format(printf,<span class="number">3</span>,<span class="number">4</span>)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？）</p>
<p>这里给出测试用例：attribute.c，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> *format,...)</span> <span class="title">attribute__</span><span class="params">((format(printf,<span class="number">1</span>,<span class="number">2</span>)))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%s\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%s\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;%s,%d,%d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format,...)</span> __<span class="title">attribute__</span><span class="params">((format(printf,<span class="number">1</span>,<span class="number">2</span>)))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%d\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%s\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;i=%s\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  <span class="built_in">myprint</span>(<span class="string">&quot;%s,%d,%d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc编译后会提示<code>format argument is not a pointer</code>的警告。若去掉<code>__attribute__((format(printf,1,2)))</code>，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。</p>
<p>还有一个<code>__attribute__ noreturn</code>，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的<code>abort()</code>和<code>exit()</code>的声明格式就采用了这种格式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了方便理解，大家可以参考如下的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name: noreturn.c ；测试__attribute__((noreturn))</span></span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myexit</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">myexit</span>();</span><br><span class="line">      <span class="comment">/* 程序不可能到达这里*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>//name: noreturn.c ；测试__attribute__((noreturn))</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">myexit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">myexit</span>();</span><br><span class="line">    <span class="comment">/* 程序不可能到达这里*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的输出结果如下：</p>
<p><code>$gcc –Wall –c noreturn.c</code></p>
<p>noreturn.c: In function `test':</p>
<p>noreturn.c:12: warning: control reaches end of non-void function</p>
<p>很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上_<em>attribute_</em>((noreturn))则可以解决此问题的出现。</p>
<p>后面还有<code>__attribute__const</code>、<code>-finstrument-functions</code>、<code>no_instrument_function</code>等的属性描述，就不多转了，感兴趣的可以看原文。</p>
<h2 id="变量属性variable-attribute">变量属性(Variable Attribute)</h2>
<p>关键字<code>__attribute__</code>也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。</p>
<p>在使用<code>__attribute__</code>参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用<code>__attribute__</code>而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</p>
<h3 id="aligned-alignment">aligned (alignment)</h3>
<p>该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如：</p>
<p><code>int x __attribute__ ((aligned (16))) = 0;</code></p>
<p>编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写：</p>
<p><code>struct foo &#123; int x[2] __attribute__ ((aligned (8))); &#125;;</code></p>
<p>如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如：</p>
<p><code>short array[3] __attribute__ ((aligned));</code></p>
<ol type="1">
<li><p>选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。</p></li>
<li><p>需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。</p></li>
<li><p>使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。</p></li>
</ol>
<p>下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] __attribute__ ((packed));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其它可选的属性值还可以是：<code>cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport</code>等。</p>
<h2 id="类型属性type-attribute">类型属性（Type Attribute）</h2>
<p>关键字<code>__attribute__</code>也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：<code>aligned, packed, transparent_union, unused, deprecated</code>和
<code>may_alias</code>。</p>
<p>在使用<code>__attribute__</code>参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用<code>__aligned__</code>而不是<code>aligned</code>，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</p>
<h3 id="aligned-alignment-1">aligned (alignment)</h3>
<p>该属性设定一个指定大小的对齐格式（以字节为单位），例如：</p>
<p><code>struct S &#123; short f[3]; &#125; __attribute__ ((aligned (8)));</code></p>
<p><code>typedef int more_aligned_int __attribute__ ((aligned (8)));</code></p>
<pre><code>该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。</code></pre>
<p>如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如：</p>
<p><code>struct S &#123; short f[3]; &#125; __attribute__ ((aligned));</code></p>
<p>这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。</p>
<ol type="1">
<li><p>aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。</p></li>
<li><p>需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。</p></li>
<li><p>使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it
indicates that the smallest integral type should be used）。</p></li>
</ol>
<p>下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_unpacked_struct</span>&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_packed_struct</span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">my_unpacked_struct</span> s;</span><br><span class="line">&#125;__attribute__ ((__packed__));</span><br></pre></td></tr></table></figure>
<h2 id="变量属性与类型属性举例">变量属性与类型属性举例</h2>
<p>下面的例子中使用<code>__attribute__</code>属性定义了一些结构体及其变量，并给出了输出结果和对结果的分析。</p>
<p>程序代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  程序代码为：</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">p</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">  &#125;__attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>))) pp;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">q</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">n</span> qn;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">  &#125;__attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>))) qq;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int)=%d,sizeof(short)=%d.sizeof(char)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">short</span>),<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pp=%d,qq=%d \n&quot;</span>, <span class="built_in">sizeof</span>(pp),<span class="built_in">sizeof</span>(qq));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>输出结果： sizeof(int)=4,sizeof(short)=2.sizeof(char)=1
pp=8,qq=24</p></li>
<li><p>结果分析： sizeof(int)=4,sizeof(short)=2.sizeof(char)=1
pp=8,qq=24 sizeof(pp): sizeof(a)+ sizeof(b)+ sizeof(c)=4+1+1=6&lt;23=8=
sizeof(pp) sizeof(qq): sizeof(a)+ sizeof(b)=4+1=5
sizeof(qn)=8;即qn是采用8字节对齐的，所以要在a，b后面添3个空余字节，然后才能存储qn，
4+1+（3）+8+1=17
因为qq采用的对齐是8字节对齐，所以qq的大小必定是8的整数倍，即qq的大小是一个比17大又是8的倍数的一个最小值，由此得到
17&lt;24+8=24= sizeof(qq)</p></li>
</ul>
<h2 id="declspec"><code>__declspec</code></h2>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 35%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Compiler</th>
<th style="text-align: left;">Simple deprecation</th>
<th style="text-align: left;">Deprecation with message</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">gcc and clang</td>
<td
style="text-align: left;"><code>__attribute__((deprecated)) int a;</code></td>
<td
style="text-align: left;"><code>__attribute__((deprecated("message"))) int a;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Visual Studio</td>
<td
style="text-align: left;"><code>__declspec(deprecated) int a;</code></td>
<td
style="text-align: left;"><code>__declspec(deprecated("message")) int a;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Embarcadero(1)</td>
<td style="text-align: left;"><code>int a [[deprecated]];</code></td>
<td
style="text-align: left;"><code>int a [[deprecated("message")]];</code></td>
</tr>
</tbody>
</table>
<p><a
target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html">table
from</a> <a
target="_blank" rel="noopener" href="http://www.cnblogs.com/ylhome/archive/2010/07/10/1774770.html"><code>__declspec</code>
blog</a></p>
<h2 id="gcc-__attribute__关键字举例之visibility">gcc
<code>__attribute__</code>关键字举例之<code>visibility</code></h2>
<p>看opencv的源代码的时候，发现<code>CV_EXPORT</code>的宏定义是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__) &amp;&amp; defined CVAPI_EXPORTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CV_EXPORTS __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 4</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CV_EXPORTS __attribute__ ((visibility (<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CV_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我就发现了新大陆似的开始找这个属性的特点。这个在工程中尤其重要，我们实现的函数要想被其他用户调用，就必须使用<code>visibility</code>让
用户可见，否则我们的实现的功能函数对用户隐藏，出现"undefined
reference".</p>
<blockquote>
<p>visibility用于设置动态链接库中函数的可见性，将变量或函数设置为hidden，则该符号仅在本so中可见，在其他库中则不可见。</p>
</blockquote>
<p>g++在编译时，可用参数<code>-fvisibility</code>指定所有符号的可见性(不加此参数时默认外部可见，参考man
g++中<code>-fvisibility</code>部分)；若需要对特定函数的可见性进行设置，需在代码中使用<code>__attribute__</code>设置visibility属性。</p>
<p>编写大型程序时，可用<code>-fvisibility=hidden</code>设置符号默认隐藏，针对特定变量和函数，在代码中使用<code>__attribute__ ((visibility("default")))</code>另该符号外部可见，这种方法可用有效避免so之间的符号冲突。</p>
<p>下面是visibility的实例，这里extern “C”可以省略（另外两篇文章 gcc
<code>__attribute__</code>关键字举例之alias 和 C++覆盖系统函数的方法
中extern "C"不可用省略）。</p>
<p>值得注意的是，visibility2.cc中可以调用fun1，原因是visibility1.o和visibility2.o同属于一个so文件。</p>
<blockquote>
<p>visibility1.cc：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;in %s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__ ((<span class="built_in">visibility</span>(<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>若编译此文件时使用了参数<code>-fvisibility=hidden</code>，则此行可以省略</p>
<blockquote>
<p>visibility2.cc：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fun1</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;in %s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__ ((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>;<span class="comment">//若编译此文件时没有使用参数-fvisibility或设置参数-fvisibility=default，则此行可以省略</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fun1</span>();</span><br><span class="line">  <span class="built_in">fun2</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Makefile：</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:test</span></span><br><span class="line"><span class="section">test:main.o libvisibility.so</span></span><br><span class="line">        g++ -o test main.o -lvisibility -L .</span><br><span class="line"><span class="section">main.o::main.cc</span></span><br><span class="line">        g++ -c main.cc</span><br><span class="line"><span class="section">libvisibility.so:visibility1.o visibility2.o</span></span><br><span class="line">        g++ -shared -o libvisibility.so visibility1.o visibility2.o</span><br><span class="line"><span class="section">visibility1.o:visibility1.cc</span></span><br><span class="line">        g++ -fvisibility=hidden -fPIC -c visibility1.cc</span><br><span class="line"><span class="section">visibility2.o:visibility2.cc</span></span><br><span class="line">        g++ -fvisibility=hidden -fPIC -c visibility2.cc</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f *.o *.so test</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译和输出： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ -c main.cc</span><br><span class="line">g++ -fvisibility=hidden -fPIC -c visibility1.cc</span><br><span class="line">g++ -fvisibility=hidden -fPIC -c visibility2.cc</span><br><span class="line">g++ -shared -o libvisibility.so visibility1.o visibility2.o</span><br><span class="line">g++ -o <span class="built_in">test</span> main.o -lvisibility -L .</span><br><span class="line">main.o: In <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.cc:(.text+0x5): undefined reference to `fun1&#x27;</span></span><br><span class="line">collect2: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make: *** [<span class="built_in">test</span>] Error 1</span><br></pre></td></tr></table></figure>
可以看到，<code>main()</code>中可以不可用调用<code>fun1</code>,可以调用<code>fun2</code>，因为<code>fun1</code>已经设置为外部不可见，<code>fun2</code>设置为外部可见。</p>
</blockquote>
<p>使用readelf对各个.o文件分析可以看到，fun1的Vis属性为HIDDEN，fun2的Vis属性为DEFAULT：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s visibility1.o|grep fun</span><br><span class="line">6: 0000000000000007    5 OBJECT  LOCAL  DEFAULT    6 _ZZ4fun1E12__FUNCTION__</span><br><span class="line">12: 0000000000000000    30 FUNC    GLOBAL HIDDEN    2 fun1</span><br><span class="line"></span><br><span class="line">$ readelf -s visibility2.o|grep fun</span><br><span class="line">6: 0000000000000007    5 OBJECT  LOCAL  DEFAULT    6 _ZZ4fun2E12__FUNCTION__</span><br><span class="line">12: 0000000000000000    35 FUNC    GLOBAL DEFAULT    2 fun2</span><br><span class="line">15: 0000000000000000    0 NOTYPE  GLOBAL DEFAULT  UND fun1</span><br><span class="line"></span><br><span class="line">$ readelf -s libvisibility.so|grep fun</span><br><span class="line">9: 00000000000006ac    35 FUNC    GLOBAL DEFAULT  12 fun2</span><br><span class="line">41: 000000000000071d    5 OBJECT  LOCAL  DEFAULT  14 _ZZ4fun1E12__FUNCTION__</span><br><span class="line">43: 0000000000000729    5 OBJECT  LOCAL  DEFAULT  14 _ZZ4fun2E12__FUNCTION__</span><br><span class="line">48: 000000000000068c    30 FUNC    LOCAL  HIDDEN  12 fun1</span><br><span class="line">54: 00000000000006ac    35 FUNC    GLOBAL DEFAULT  12 fun2</span><br></pre></td></tr></table></figure>
<h1 id="linux-内核中的-gcc-特性">Linux 内核中的 GCC 特性</h1>
<ul>
<li>功能性 扩展提供新功能。</li>
<li>优化 扩展帮助生成更高效的代码。</li>
</ul>
<h2 id="功能性扩展">功能性扩展</h2>
<h3 id="类型发现">类型发现</h3>
<p>GCC 允许通过变量的引用识别类型。这种操作支持泛型编程。在 C++、Ada 和
Java™ 语言等许多现代编程语言中都可以找到相似的功能。Linux 使用 typeof
构建 min 和 max 等依赖于类型的操作。清单 1 演示如何使用 typeof
构建一个泛型宏（见 ./linux/include/linux/kernel.h）。</p>
<p>清单 1. 使用 typeof 构建一个泛型宏 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define min(x, y) (&#123;                \</span><br><span class="line">    typeof(x) _min1 = (x);          \</span><br><span class="line">    typeof(y) _min2 = (y);          \</span><br><span class="line">    (void) (&amp;_min1 == &amp;_min2);      \</span><br><span class="line">    _min1 &lt; _min2 ? _min1 : _min2; &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="范围扩展">范围扩展</h3>
<p>GCC 支持范围，在 C 语言的许多方面都可以使用范围。其中之一是
switch/case 块中的 case 语句。在复杂的条件结构中，通常依靠嵌套的 if
语句实现与清单 2（见 ./linux/drivers/scsi/sd.c）相同的结果，但是清单 2
更简洁。使用 switch/case 也可以通过使用跳转表实现进行编译器优化。</p>
<p>清单 2. 在 case 语句中使用范围 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sd_major</span><span class="params">(<span class="type">int</span> major_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (major_idx) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> SCSI_DISK0_MAJOR;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> ... <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> SCSI_DISK1_MAJOR + major_idx - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">return</span> SCSI_DISK8_MAJOR + major_idx - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        BUG();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* shut up gcc */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还可以使用范围进行初始化，如下所示（见<code>./linux/arch/cris/arch-v32/kernel/smp.c</code>）。在这个示例中，<code>spinlock_t</code>
创建一个大小为<code>LOCK_COUNT</code>
的数组。数组的每个元素初始化为<code>SPIN_LOCK_UNLOCKED</code> 值。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Vector of locks used for various atomic operations */</span></span><br><span class="line"><span class="type">spinlock_t</span> cris_atomic_locks[] = &#123; [<span class="number">0</span> ... LOCK_COUNT - <span class="number">1</span>] = SPIN_LOCK_UNLOCKED&#125;;</span><br></pre></td></tr></table></figure>
范围还支持更复杂的初始化。例如，以下代码指定数组中几个子范围的初始值。
<code>int widths[] = &#123; [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 &#125;;</code></p>
<h3 id="零长度的数组">零长度的数组</h3>
<p>在 C
标准中，必须定义至少一个数组元素。这个需求往往会使代码设计复杂化。但是，GCC
支持零长度数组的概念，这对于结构定义尤其有用。这个概念与 ISO C99
中灵活的数组成员相似，但是使用不同的语法。</p>
<p>下面的示例在结构的末尾声明一个没有成员的数组（见
<code>./linux/drivers/ieee1394/raw1394-private.h</code>）。这允许结构中的元素引用结构实例后面紧接着的内存。在需要数量可变的数组成员时，这个特性很有用。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct iso_block_store &#123;</span><br><span class="line">        atomic_t refcount;</span><br><span class="line">        size_t data_size;</span><br><span class="line">        quadlet_t data[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="判断调用地址">判断调用地址</h3>
<p>在许多情况下，需要判断给定函数的调用者。GCC 提供用于此用途的内置函数
<code>__builtin_return_address</code>。这个函数通常用于调试，但是它在内核中还有许多其他用途。</p>
<p>如下面的代码所示，<code>__builtin_return_address</code> 接收一个称为
level 的参数。这个参数定义希望获取返回地址的调用堆栈级别。例如，如果指定
level 为 0，那么就是请求当前函数的返回地址。如果指定 level 为
1，那么就是请求进行调用的函数的返回地址，依此类推。
<code>void * __builtin_return_address( unsigned int level );</code>
在下面的示例中（见
./linux/kernel/softirq.c），<code>local_bh_disable</code>
函数在本地处理器上禁用软中断，从而禁止在当前处理器上运行
<code>softirqs</code>、<code>tasklets</code>和
<code>bottom halves</code>。使用<code>__builtin_return_address</code>
捕捉返回地址，以便在以后进行跟踪时使用这个地址。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void local_bh_disable(void)&#123;</span><br><span class="line">        __local_bh_disable((unsigned long)__builtin_return_address(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="常量检测">常量检测</h3>
<p>在编译时，可以使用 GCC
提供的一个内置函数判断一个值是否是常量。这种信息非常有价值，因为可以构造出能够通过常量叠算（constant
folding）优化的表达式。<code>__builtin_constant_p</code>
函数用来检测常量。</p>
<p><code>__builtin_constant_p</code>
的原型如下所示。注意，<code>__builtin_constant_p</code>
并不能检测出所有常量，因为 GCC 不容易证明某些值是否是常量。
<code>int __builtin_constant_p( exp )</code> Linux
相当频繁地使用常量检测。在清单 3 所示的示例中（见
./linux/include/linux/log2.h），使用常量检测优化
<code>roundup_pow_of_two</code>
宏。如果发现表达式是常量，那么就使用可以优化的常量表达式。如果表达式不是常量，就调用另一个宏函数把值向上取整到
2 的幂。</p>
<p>清单 3. 使用常量检测优化宏函数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define roundup_pow_of_two(n)           \</span><br><span class="line">(                       \</span><br><span class="line">    __builtin_constant_p(n) ? (     \</span><br><span class="line">        (n == 1) ? 1 :          \</span><br><span class="line">        (1UL &lt;&lt; (ilog2((n) - 1) + 1)) \</span><br><span class="line">                   ) :      \</span><br><span class="line">    __roundup_pow_of_two(n)         \</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="函数属性">函数属性</h3>
<p>GCC
提供许多函数级属性，可以通过它们向编译器提供更多数据，帮助编译器执行优化。本节描述与功能相关联的一些属性。下一节描述
影响优化的属性。</p>
<p>如清单 4
所示，属性通过其他符号定义指定了别名。可以以此帮助阅读源代码参考，了解属性的使用方法（见
./linux/include/linux/compiler-gcc3.h）。</p>
<p>清单 4. 函数属性定义 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># define __inline__  __inline__  __attribute__((always_inline))</span><br><span class="line"># define __deprecated           __attribute__((deprecated))</span><br><span class="line"># define __attribute_used__     __attribute__((__used__))</span><br><span class="line"># define __attribute_const__     __attribute__((__const__))</span><br><span class="line"># define __must_check            __attribute__((warn_unused_result))</span><br></pre></td></tr></table></figure> 清单 4 所示的定义是 GCC
中可用的一些函数属性。它们也是在 Linux
内核中最有用的函数属性。下面解释如何使用这些属性： -
<code>always_inline</code> 让 GCC
以内联方式处理指定的函数，无论是否启用了优化。 - <code>deprecated</code>
指出函数已经被废弃，不应该再使用。如果试图使用已经废弃的函数，就会收到警告。还可以对类型和变量应用这个属性，促使开发人员尽可能少使用它们。
- <code>__used__</code> 告诉编译器无论 GCC
是否发现这个函数的调用实例，都要使用这个函数。这对于从汇编代码中调用 C
函数有帮助。 - <code>__const__</code>
告诉编译器某个函数是无状态的（也就是说，它使用传递给它的参数生成要返回的结果）。
- <code>warn_unused_result</code>
让编译器检查所有调用者是否都检查函数的结果。这确保调用者适当地检验函数结果，从而能够适当地处理错误。</p>
<p>下面是在 Linux 内核中使用这些属性的示例。deprecated
示例来自与体系结构无关的内核（./linux/kernel/resource.c），const
示例来自 IA64 内核源代码（./linux/arch/ia64/kernel/unwind.c）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __deprecated __check_region(<span class="keyword">struct</span> resource </span><br><span class="line">    *parent, <span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">enum</span> unw_register_index __attribute_const__ </span></span><br><span class="line"><span class="function">    <span class="title">decode_abreg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> abreg, <span class="type">int</span> memory)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="优化扩展">优化扩展</h2>
<p>现在，讨论有助于生成更好的机器码的一些 GCC 特性。</p>
<h3 id="分支预测提示">分支预测提示</h3>
<p>在 Linux
内核中最常用的优化技术之一是<code>__builtin_expect</code>。在开发人员使用有条件代码时，常常知道最可能执行哪个分支，而哪个分支很少执行。如果编译器知道这种预测信息，就可以围绕最可能执行的分支生成最优的代码。</p>
<p>如下所示，<code>__builtin_expect</code> 的使用方法基于两个宏 likely
和 unlikely（见 ./linux/include/linux/compiler.h）。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(x)   __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure>
通过使用
<code>__builtin_expect</code>，编译器可以做出符合提供的预测信息的指令选择决策。这使执行的代码尽可能接近实际情况。它还可以改进缓存和指令流水线。</p>
<p>例如，如果一个条件标上了 “likely”，那么编译器可以把代码的 True
部分直接放在分支指令后面（这样就不需要执行分支指令）。通过分支指令访问条件结构的
False
部分，这不是最优的方式，但是访问它的可能性不大。按照这种方式，代码对于最可能出现的情况是最优的。</p>
<p>清单 5 给出一个使用 likely 和 unlikely 宏的函数（见
./linux/net/core/datagram.c）。这个函数预测 sum 变量将是零（数据包的
checksum 是有效的），而且 ip_summed 变量不等于 CHECKSUM_HW。</p>
<p>清单 5. likely 和 unlikely 宏的使用示例 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __skb_checksum_complete(<span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> sum;</span><br><span class="line"> </span><br><span class="line">        sum = (u16)<span class="built_in">csum_fold</span>(<span class="built_in">skb_checksum</span>(skb, <span class="number">0</span>, skb-&gt;len, skb-&gt;csum));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">likely</span>(!sum)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">unlikely</span>(skb-&gt;ip_summed == CHECKSUM_HW))</span><br><span class="line">                        <span class="built_in">netdev_rx_csum_fault</span>(skb-&gt;dev);</span><br><span class="line">                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="预抓取">预抓取</h3>
<p>另一种重要的性能改进方法是把必需的数据缓存在接近处理器的地方。缓存可以显著减少访问数据花费的时间。大多数现代处理器都有三类内存：
* 一级缓存通常支持单周期访问 * 二级缓存支持两周期访问 *
系统内存支持更长的访问时间</p>
<p>为了尽可能减少访问延时并由此提高性能，最好把数据放在最近的内存中。手工执行这个任务称为预抓取。GCC
通过内置函数 <code>__builtin_prefetch</code>
支持数据的手工预抓取。在需要数据之前，使用这个函数把数据放到缓存中。如下所示，<code>__builtin_prefetch</code>
函数接收三个参数：</p>
<ul>
<li>数据的地址</li>
<li>rw 参数，使用它指明预抓取数据是为了执行读操作，还是执行写操作</li>
<li>locality
参数，使用它指定在使用数据之后数据应该留在缓存中，还是应该清除
<code>void __builtin_prefetch( const void *addr, int rw, int locality );</code></li>
</ul>
<p>Linux 内核经常使用预抓取。通常是通过宏和包装器函数使用预抓取。清单 6
是一个辅助函数示例，它使用内置函数的包装器（见
./linux/include/linux/prefetch.h）。这个函数为流操作实现预抓取机制。使用这个函数通常可以减少缓存缺失和停顿，从而提高性能。</p>
<p>清单 6. 范围预抓取的包装器函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARCH_HAS_PREFETCH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prefetch(x) __builtin_prefetch(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">prefetch_range</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_HAS_PREFETCH</span></span><br><span class="line">    <span class="type">char</span> *cp;</span><br><span class="line">    <span class="type">char</span> *end = addr + len;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (cp = addr; cp &lt; end; cp += PREFETCH_STRIDE)</span><br><span class="line">        <span class="built_in">prefetch</span>(cp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变量属性">变量属性</h3>
<p>除了本文前面讨论的函数属性之外，GCC
还为变量和类型定义提供了属性。最重要的属性之一是 <code>aligned</code>
属性，它用于在内存中实现对象对齐。除了对于性能很重要之外，某些设备或硬件配置也需要对象对齐。<code>aligned</code>
属性有一个参数，它指定所需的对齐类型。</p>
<p>下面的示例用于软件暂停（见
./linux/arch/i386/mm/init.c）。在需要页面对齐时，定义
<code>PAGE_SIZE</code> 对象。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char __nosavedata swsusp_pg_dir[PAGE_SIZE]</span><br><span class="line">    __attribute__ ((aligned (PAGE_SIZE)));</span><br></pre></td></tr></table></figure> 清单 7
中的示例说明关于优化的两点：</p>
<p><code>packed</code>
属性打包一个结构的元素，从而尽可能减少它们占用的空间。这意味着，如果定义一个
char 变量，它占用的空间不会超过一字节（8
位）。位字段压缩为一位，而不会占用更多存储空间。
这段源代码使用一个<code>__attribute__</code>
声明进行优化，它用逗号分隔的列表定义多个属性。 清单 7.
结构打包和设置多个属性 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">swsusp_header</span> &#123;</span><br><span class="line">        <span class="type">char</span> reserved[PAGE_SIZE - <span class="number">20</span> - <span class="built_in">sizeof</span>(<span class="type">swp_entry_t</span>)];</span><br><span class="line">        <span class="type">swp_entry_t</span> image;</span><br><span class="line">        <span class="type">char</span>    orig_sig[<span class="number">10</span>];</span><br><span class="line">        <span class="type">char</span>    sig[<span class="number">10</span>];</span><br><span class="line">&#125; __attribute__((packed, <span class="built_in">aligned</span>(PAGE_SIZE))) swsusp_header;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接">参考链接</h2>
<ol type="1">
<li><p><a
target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Function
Attributes</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Visibility-Pragmas.html#Visibility-Pragmas">Visibility
Pragmas</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="http://liulixiaoyao.blog.51cto.com/1361095/814329">GCC扩展
<strong>attribute</strong> ((visibility("hidden")))</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-gcc-hacks/">【IBM】Linux
内核中的 GCC 特性</a></p></li>
</ol>

    </div>

    
    
    
      


    <footer class="post-footer"><div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="share.title"
      
      
        data-wechat-qrcode-helper="share.prompt"
      
    >
    </div>
  </div>
  <script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js"></script>
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>CharlesCao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/" title="C++ Programming Tricks">http://www.deepindeed.cn/201811/20181128-gnu-cpp-programming-tricks/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E5%BC%80%E5%8F%91/" rel="tag"># 开发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/201811/20181111-hight-property-codes/" rel="prev" title="《高质量的C++代码笔记》">
                  <i class="fa fa-chevron-left"></i> 《高质量的C++代码笔记》
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/201812/20181204-dev-problem-android-string-crash/" rel="next" title="android开发中奇怪crash问题">
                  android开发中奇怪crash问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-waline">waline</a></li>
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane waline" id="comment-waline">
              <div class="comments" id="waline"></div>
            </div>
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CharlesCao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">510k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:10</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@9.0.1/dist/mermaid.min.js","integrity":"sha256-CemUs9ITT7liCZpVMktcEw0BpAOZ1+mujlMB3UyuImU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","locale":{"placeholder":"欢迎交流指正"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/weibo","https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili","https://unpkg.com/@waline/emojis@1.0.1/qq","https://unpkg.com/@waline/emojis@1.0.1/tieba","https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"],"meta":["nick","mail"],"requiredMeta":["mail","nick","mail"],"login":"enable","el":"#waline","comment":true,"path":"/201811/20181128-gnu-cpp-programming-tricks/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"cwlseu","repo":"blog-comment","client_id":"a3c364d3dade81cbba30","client_secret":"e1093c6387bfa715f2cb4b6aee010c94deb253ee","admin_user":"cwlseu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d0567934f981bb8f4b2390ab85593f84"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
